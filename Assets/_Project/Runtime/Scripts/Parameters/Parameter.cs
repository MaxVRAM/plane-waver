using System;
using System.Collections.Generic;
using UnityEngine;
using MaxVRAM.Extensions;
using PlaneWaver.Interaction;

namespace PlaneWaver.Parameters
{
    [Serializable]
    public partial class Parameter
    {
        protected ParameterDefault Defaults;
        public InputSource ModulationInput;
        public ModulationDataObject ModulationData;

        private Actor _actor;
        protected bool VolatileEmitter;
        protected float SourceInputValue;
        protected float ModulationOutputValue;
        private float _previousSmoothedValue;
        private bool _isInitialised;
        
        public Parameter(bool volatileEmitter = false)
        {
            VolatileEmitter = volatileEmitter;
            ModulationInput = new InputSource();
        }

        public void Reset()
        {
            ModulationInput = new InputSource();
            ModulationData = new ModulationDataObject(Defaults);
            ModulationData.Initialise();
        }

        public void Initialise(in Actor actor)
        {
            _actor = actor;
            ModulationData.Initialise();
            _isInitialised = true;
        }
        
        public ModulationComponent CreateModulationComponent()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");

            ModulationOutputValue = GetModulationValue();
            return ModulationData.BuildComponent(ModulationOutputValue);
        }

        public float GetModulationValue()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");
            
            _previousSmoothedValue = ModulationOutputValue;
            SourceInputValue = ModulationInput.GetInputValue(_actor);
            
            return Process(SourceInputValue);
        }

        /// <summary>
        ///     Generates an emitter modulation value based on the source input value and the ModulationParameter.
        /// </summary>
        /// <param name="sourceInputValue">Float value generated by the modulation input source.</param>
        /// <returns>Float: Processed modulation value to control emitter parameters.</returns>
        public float Process(float sourceInputValue)
        {
            float outputValue = 0;
            float input = sourceInputValue * ModulationData.ModInputMultiplier;
            float inputNormalised = Mathf.InverseLerp
                    (ModulationData.ModInputRange.x, ModulationData.ModInputRange.y, input);
            float preSmoothing = ModulationData.Accumulate ? _previousSmoothedValue + inputNormalised : inputNormalised;
            float smoothedValue = _previousSmoothedValue.Smooth(preSmoothing, ModulationData.Smoothing);
            _previousSmoothedValue = smoothedValue;

            if (ModulationData.VolatileEmitter)
                outputValue = ModulationData.LimiterMode switch {
                    ModulationLimiter.Clip     => Mathf.Clamp(smoothedValue, 0, 1),
                    ModulationLimiter.Repeat   => smoothedValue.RepeatNorm(),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm(),
                    _                          => smoothedValue
                };
            else
                outputValue = ModulationData.LimiterMode switch {
                    ModulationLimiter.Clip => ModulationData.OutputOffset +
                                              Mathf.Pow(Mathf.Clamp01(smoothedValue),ModulationData.ModExponent) *
                                              ModulationData.ModInfluence,
                    ModulationLimiter.Repeat => smoothedValue.RepeatNorm
                            (ModulationData.ModInfluence, ModulationData.OutputOffset),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm
                            (ModulationData.ModInfluence, ModulationData.OutputOffset),
                    _ => smoothedValue
                };

            return outputValue;
        }
    }
}