using System;
using UnityEngine;
using MaxVRAM.Extensions;
using PlaneWaver.Interaction;

namespace PlaneWaver.Modulation
{
    [Serializable]
    public partial class Parameter
    {
        public PropertiesObject ParameterProperties;
        public ModulationInputObject ModulationInput;
        public ModulationDataObject ModulationData;

        private ActorObject _actor;
        protected bool IsVolatileEmitter;
        protected float SourceInputValue;
        protected float ModulationOutputValue;
        private float _previousSmoothedValue;
        private bool _isInitialised;
        
        public Parameter(bool isVolatileEmitter = false)
        {
            IsVolatileEmitter = isVolatileEmitter;
            ModulationInput = new ModulationInputObject();
        }

        public void Reset()
        {
            ModulationInput = new ModulationInputObject();
            ModulationData = new ModulationDataObject(ParameterProperties);
            ModulationData.Initialise();
        }

        public void Initialise(in ActorObject actor)
        {
            _actor = actor;
            ModulationData.Initialise();
            _isInitialised = true;
        }
        
        public ModulationComponent CreateModulationComponent()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");

            float inputValue = ModulationData.Enabled ? UpdateSourceInput() : 0;
            float modulationValue = UpdateModulationValue(inputValue);
            return ModulationData.BuildComponent(modulationValue);
        }
        
        public float UpdateSourceInput(ActorObject actor = null)
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");
            
            SourceInputValue = ModulationInput.GetValue(actor ? actor : _actor);
            return SourceInputValue;
        }

        public float UpdateModulationValue(float sourceInputValue)
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");
            
            ModulationOutputValue = Process(sourceInputValue);
            return ModulationOutputValue;
        }

        /// <summary>
        /// Creates a normalised value for applying to parameter modulations from a given source input value.
        /// Input value is processed using the parameter's ModulationData configuration for the given parameter.
        /// </summary>
        /// <param name="inputValue">Float value generated by the modulation input source.</param>
        /// <returns>Float: Processed modulation value to control emitter parameters.</returns>
        public float Process(float inputValue)
        {
            if (!ModulationData.Enabled) return IsVolatileEmitter ? 0 : ModulationData.InitialValue;
            
            float outputValue;
            float input = inputValue * ModulationData.ModInputMultiplier;
            float inputNormalised = Mathf.InverseLerp
                    (ModulationData.ModInputRange.x, ModulationData.ModInputRange.y, input);
            float preSmoothing = ModulationData.Accumulate ? _previousSmoothedValue + inputNormalised : inputNormalised;
            float smoothedValue = _previousSmoothedValue.Smooth(preSmoothing, ModulationData.Smoothing);
            _previousSmoothedValue = smoothedValue;

            if (ModulationData.IsVolatileEmitter)
                outputValue = ModulationData.LimiterMode switch {
                    ModulationLimiter.Clip     => Mathf.Clamp(smoothedValue, 0, 1),
                    ModulationLimiter.Wrap   => smoothedValue.WrapNorm(),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm(),
                    _                          => smoothedValue
                };
            else
                outputValue = ModulationData.LimiterMode switch {
                    ModulationLimiter.Clip => ModulationData.InitialValue +
                                              Mathf.Pow(Mathf.Clamp01(smoothedValue),ModulationData.ModExponent) *
                                              ModulationData.ModInfluence,
                    ModulationLimiter.Wrap => smoothedValue.WrapNorm
                            (ModulationData.ModInfluence, ModulationData.InitialValue),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm
                            (ModulationData.ModInfluence, ModulationData.InitialValue),
                    _ => smoothedValue
                };

            return outputValue;
        }
    }
}