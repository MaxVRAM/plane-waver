using System;
using System.Collections.Generic;
using UnityEngine;
using MaxVRAM.Extensions;
using PlaneWaver.Interaction;

namespace PlaneWaver.Parameters
{
    [Serializable]
    public partial class Parameter
    {
        protected ParameterDefault Defaults;
        public InputSource ModulationInput;
        public DataObject Data;

        private Actor _actor;
        protected bool VolatileEmitter;
        protected float SourceInputValue;
        protected float ModulationOutputValue;
        private float _previousSmoothedValue;
        private bool _isInitialised;
        
        public Parameter(bool volatileEmitter = false)
        {
            VolatileEmitter = volatileEmitter;
            ModulationInput = new InputSource();
        }

        public void Reset()
        {
            ModulationInput = new InputSource();
            Data = new DataObject(Defaults);
            Data.Initialise();
        }

        public void Initialise(in Actor actor)
        {
            _actor = actor;
            Data.Initialise();
            _isInitialised = true;
        }
        
        public ModulationComponent CreateModulationComponent()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");

            ModulationOutputValue = GetModulationValue();
            return Data.BuildComponent(ModulationOutputValue);
        }

        public float GetModulationValue()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");
            
            _previousSmoothedValue = ModulationOutputValue;
            SourceInputValue = ModulationInput.GetInputValue(_actor);
            
            return Process(SourceInputValue);
        }

        /// <summary>
        ///     Generates an emitter modulation value based on the source input value and the ModulationParameter.
        /// </summary>
        /// <param name="sourceInputValue">Float value generated by the modulation input source.</param>
        /// <returns>Float: Processed modulation value to control emitter parameters.</returns>
        public float Process(float sourceInputValue)
        {
            float outputValue = 0;
            float input = sourceInputValue * Data.ModInputMultiplier;
            float inputNormalised = Mathf.InverseLerp
                    (Data.ModInputRange.x, Data.ModInputRange.y, input);
            float preSmoothing = Data.Accumulate ? _previousSmoothedValue + inputNormalised : inputNormalised;
            float smoothedValue = _previousSmoothedValue.Smooth(preSmoothing, Data.Smoothing);
            _previousSmoothedValue = smoothedValue;

            if (Data.VolatileEmitter)
                outputValue = Data.LimiterMode switch {
                    ModulationLimiter.Clip     => Mathf.Clamp(smoothedValue, 0, 1),
                    ModulationLimiter.Repeat   => smoothedValue.RepeatNorm(),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm(),
                    _                          => smoothedValue
                };
            else
                outputValue = Data.LimiterMode switch {
                    ModulationLimiter.Clip => Data.InitialValue +
                                              Mathf.Pow(Mathf.Clamp01(smoothedValue),Data.ModExponent) *
                                              Data.ModInfluence,
                    ModulationLimiter.Repeat => smoothedValue.RepeatNorm
                            (Data.ModInfluence, Data.InitialValue),
                    ModulationLimiter.PingPong => smoothedValue.PingPongNorm
                            (Data.ModInfluence, Data.InitialValue),
                    _ => smoothedValue
                };

            return outputValue;
        }
    }
}