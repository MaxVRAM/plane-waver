using System;
using UnityEngine;
using MaxVRAM.Extensions;
using PlaneWaver.Interaction;

namespace PlaneWaver.Modulation
{
    [Serializable]
    public partial class Parameter
    {
        public PropertiesObject ParameterProperties;
        public ModulationInputObject ModulationInput;
        public ModulationDataObject ModulationData;

        private ActorObject _actor;
        protected bool IsVolatileEmitter;
        protected float SourceInputValue;
        protected float ModulationOutputValue;
        private float _previousSmoothedValue;
        private bool _isInitialised;

        public Parameter(bool isVolatileEmitter = false)
        {
            IsVolatileEmitter = isVolatileEmitter;
            ModulationInput = new ModulationInputObject();
        }

        public void Reset()
        {
            ModulationInput = new ModulationInputObject();
            ModulationData = new ModulationDataObject(ParameterProperties);
            ModulationData.Initialise();
        }

        public void Initialise(in ActorObject actor)
        {
            _actor = actor;
            ModulationData.Initialise();
            _isInitialised = true;
        }

        public ModulationComponent CreateModulationComponent()
        {
            if (!_isInitialised)
                throw new Exception("Parameter has not been initialised.");

            float inputValue = ModulationData.Enabled ? UpdateSourceInput() : 0;
            float modulationValue = UpdateModulationValue(inputValue);
            return ModulationData.BuildComponent(modulationValue);
        }

        public float UpdateSourceInput(ActorObject actor = null)
        {
            SourceInputValue = ModulationInput.GetValue(actor ? actor : _actor);
            return SourceInputValue;
        }

        public float UpdateModulationValue(float sourceInputValue)
        {
            ModulationOutputValue = ModulationData.Enabled ? Process
                            (sourceInputValue, ModulationData, ref _previousSmoothedValue) :
                    IsVolatileEmitter ? 0 : ModulationData.InitialValue;

            return ModulationOutputValue;
        }
        
        /// <summary>
        /// Creates a normalised value for applying to parameter modulations from a given source input value.
        /// Input value is processed using the parameter's ModulationData configuration for the given parameter.
        /// </summary>
        /// <param name="input">Float value generated by the modulation input source.</param>
        /// <param name="modData">Modulation data object containing processing configuration.</param>
        /// <param name="prevSmoothed">Reference value to maintain value for smoothing calculation.</param>
        /// <returns>Float: Processed modulation value to control emitter parameters.</returns>
        public static float Process(float input, in ModulationDataObject modData, ref float prevSmoothed)
        {
            return Process(input, modData, ref prevSmoothed, out _, out _, out _, out _);
        }

        public static float Process(
            float input, in ModulationDataObject modData, ref float smoothed, out float scaled, out float normalised,
            out float preSmoothed, out float raised)
        {
            float output;
            scaled = input * modData.ModInputMultiplier;
            normalised = Mathf.InverseLerp(modData.ModInputRange.x, modData.ModInputRange.y, scaled);
            preSmoothed = modData.Accumulate ? smoothed + normalised : normalised;
            smoothed = smoothed.Smooth(preSmoothed, modData.Smoothing);
            raised = Mathf.Pow(smoothed, modData.ModExponent);

            if (modData.IsVolatileEmitter)
                output = modData.LimiterMode switch {
                    ModulationLimiter.Clip     => Mathf.Clamp01(smoothed),
                    ModulationLimiter.Wrap     => smoothed.WrapNorm(),
                    ModulationLimiter.PingPong => smoothed.PingPongNorm(),
                    _                          => smoothed
                };
            else
                output = modData.LimiterMode switch {
                    ModulationLimiter.Clip     => Mathf.Clamp01(modData.InitialValue + raised * modData.ModInfluence),
                    ModulationLimiter.Wrap     => raised.WrapNorm(modData.ModInfluence, modData.InitialValue),
                    ModulationLimiter.PingPong => raised.PingPongNorm(modData.ModInfluence, modData.InitialValue),
                    _                          => raised
                };

            return output;
        }
    }
}